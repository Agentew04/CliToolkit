using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Cli.Toolkit.Generators;

/// <summary>
/// Generates code for a thread safe property
/// </summary>
[Generator]
public class ThreadSafeGenerator : IIncrementalGenerator {

    private const string Namespace = "Cli.Toolkit.Generators";
    private const string AttributeName = "ThreadSafeAttribute";

    private const string AttributeSourceCode = $@"// <auto-generated/>

namespace {Namespace}
{{
    /// <summary>
    /// Attribute to mark a field as thread safe. Gets and sets to the
    /// property will have locks
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Field)]
    public class {AttributeName} : System.Attribute
    {{
    }}
}}";
    
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "ThreadSafeAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var fields = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => IsSyntaxTargetForGeneration(s),
                (ctx, _) => GetTargetForGeneration(ctx));

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(fields.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }
    
    private static bool IsSyntaxTargetForGeneration(SyntaxNode syntaxNode) {
        if (syntaxNode is not FieldDeclarationSyntax fieldDeclarationSyntax) {
            return false;
        }

        if (fieldDeclarationSyntax.AttributeLists.Count == 0) {
            return false;
        }

        foreach (AttributeListSyntax attributeListSyntax in fieldDeclarationSyntax.AttributeLists)
        foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes) {
            if(attributeSyntax.Name.ToString() == "ThreadSafe") {
                return true;
            }
        }

        return false;
    }
    
    private static FieldDeclarationSyntax GetTargetForGeneration(GeneratorSyntaxContext ctx) {
        return (FieldDeclarationSyntax)ctx.Node;
    }
    
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<FieldDeclarationSyntax> fields) {
        foreach (FieldDeclarationSyntax? field in fields) {
            if (field is null) {
                continue;
            }
            SemanticModel model = compilation.GetSemanticModel(field.SyntaxTree);
            ClassDeclarationSyntax classDeclaration = (ClassDeclarationSyntax)field.Parent!;
            INamespaceSymbol namespaceSymbol = ModelExtensions.GetDeclaredSymbol(model, classDeclaration)!.ContainingNamespace;
            TypeSyntax type = field.Declaration.Type;
            IFieldSymbol fieldSymbol = (IFieldSymbol)ModelExtensions.GetDeclaredSymbol(model, field.Declaration.Variables[0])!;
            
            // check if class is partial
            if (!classDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword)) {
                var error = Diagnostic.Create(DiagnosticDescriptors.NotPartialClassMessage,
                    classDeclaration.GetLocation());
                context.ReportDiagnostic(error);
                continue;
            }
            
            string namespaceName = namespaceSymbol.ToDisplayString();
            string className = classDeclaration.Identifier.Text;
            string fieldName = fieldSymbol.Name;
            string fieldType = fieldSymbol.Type.ToDisplayString();
            string propertyName;
            string lockName = fieldName + "_lock";
            if(fieldName.StartsWith("_")) {
                propertyName = fieldName.Substring(1, 1).ToUpper() + fieldName.Substring(2);
            }
            else {
                propertyName = fieldName.Substring(0, 1).ToUpper() + fieldName.Substring(1);
            }
            bool isStatic = field.Modifiers.Any(SyntaxKind.StaticKeyword);

            // Go through all class members with a particular type (property) to generate method lines.
            string lockObj =
                $$"""
                /// <summary>
                /// Lock object for the property <see cref={{propertyName}}"/>
                /// </summary>
                private {{(isStatic ? "static " : "")}}readonly object {{lockName}} = new();
                """;
            string property = 
                $$"""
                /// <inheritdoc cref="{{fieldName}}"/>
                public {{(isStatic ? "static " : "")}}{{fieldType}} {{propertyName}} {
                    get {
                        lock ({{lockName}}) {
                            return {{fieldName}};
                        }
                    }
                    set {
                        lock ({{lockName}}) {
                            {{fieldName}} = value;
                        }
                    }
                }
                """;

            // Build up the source code
            var code =
                $$"""
                  // <auto-generated/>
                  
                  namespace {{namespaceName}};
                  public partial class {{className}} {
                      {{lockObj}}
                      {{property}}
                  }
                  """;
                

            // Add the source code to the compilation.
            context.AddSource($"{className}.{fieldName}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}